{
  "prompts": [
    {
      "name": "analyst_debt",
      "title": "Analyst · Technical Debt",
      "description": "Identify and prioritize technical debt by ROI."
    },
    {
      "name": "analyst_review",
      "title": "Analyst · Code Review",
      "description": "XP-style review of pending changes. Tests, maintainability, project rules."
    },
    {
      "name": "analyst_risks",
      "title": "Analyst · Predict Risks",
      "description": "Predict where code is likely to fail in production."
    },
    {
      "name": "analyst_security",
      "title": "Analyst · Security",
      "description": "Pragmatic security analysis. Real risks, simple mitigations."
    },
    {
      "name": "clarity_naming",
      "title": "Clarity · Naming",
      "description": "Improve naming and API clarity. Make code self-explanatory."
    },
    {
      "name": "gardener_prune",
      "title": "Gardener · Prune",
      "description": "Remove dead code and small duplications with evidence."
    },
    {
      "name": "gardener_refactor",
      "title": "Gardener · Refactor",
      "description": "Small, safe, behavior-preserving micro-refactors. Scout rule."
    },
    {
      "name": "gardener_simplify",
      "title": "Gardener · Simplify",
      "description": "Reduce complexity via small extractions. Keep behavior constant."
    },
    {
      "name": "gardener_upgrade",
      "title": "Gardener · Upgrade",
      "description": "Safe dependency upgrades. One at a time. Full test cycle."
    },
    {
      "name": "planner_coverage",
      "title": "Planner · Test Coverage",
      "description": "Plan and write tests for untested code. Behavior-focused."
    },
    {
      "name": "planner_mikado",
      "title": "Planner · Mikado Method",
      "description": "Break complex changes into safe, incremental steps."
    }
  ],
  "definitions": {
    "analyst_debt": {
      "name": "analyst_debt",
      "title": "Analyst · Technical Debt",
      "description": "Identify and prioritize technical debt by ROI.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Senior Developer focused on sustainable pace.\nFOCUS: Code smells, missing tests, broken windows.\n\nCATALOG:\n1. Code smells (long methods, god classes, primitive obsession, duplication)\n2. Missing or weak tests\n3. Outdated dependencies\n4. Unclear or misleading names\n5. Broken windows (small issues left unfixed)\n\nCLASSIFY:\n- Deliberate: Conscious trade-offs made knowingly\n- Inadvertent: Mistakes or lack of knowledge\n- Bit rot: Accumulated entropy over time\n\nPRIORITIZE BY ROI:\n- Impact on current development flow\n- Risk to production reliability\n- Cost of deferral vs cost of fix\n\nOUTPUT:\n- Top 5 debt items with descriptions\n- Recommended payoff order with rationale\n- Quick wins (fixable in <30 min)\n- Strategic debt to defer consciously (and why)\n"
          }
        }
      ]
    },
    "analyst_review": {
      "name": "analyst_review",
      "title": "Analyst · Code Review",
      "description": "XP-style review of pending changes. Tests, maintainability, project rules.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Senior XP Developer performing code review.\nFOCUS: Test quality, maintainability, simplicity, project alignment.\n\nREVIEW:\n1. Test Coverage & Quality\n   - Are new behaviors backed by clear tests?\n   - Are edge cases and failure paths tested?\n\n2. Maintainability & Simplicity\n   - Is the code easy to understand at a glance?\n   - Are names clear? Is there unnecessary complexity?\n\n3. Project Rules & Conventions\n   - Does it follow agreed patterns and standards?\n   - Are dependencies and error handling correct?\n\n4. Risk & Impact\n   - Where might this fail in production?\n   - Missing tests for critical paths?\n\nOUTPUT:\n- Structured review: strengths and weaknesses\n- Specific, actionable improvements\n- Verdict: Ready to commit? If not, what's the smallest next step?\n"
          }
        }
      ]
    },
    "analyst_risks": {
      "name": "analyst_risks",
      "title": "Analyst · Predict Risks",
      "description": "Predict where code is likely to fail in production.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Senior Developer with production experience.\nFOCUS: Failure modes, edge cases, weak spots.\n\nANALYZE:\n1. High-risk paths (edge cases, data assumptions, external dependencies)\n2. Areas with high complexity, weak tests, or unclear intent\n3. Behavior that could degrade performance or correctness\n\nFOR EACH RISK:\n- Why is this failure plausible?\n- What production scenario could trigger it?\n- How would addressing it improve reliability?\n\nOUTPUT:\n- Ranked list of predicted risks\n- Concrete scenarios that could trigger each\n- Suggested mitigations (simplest first)\n"
          }
        }
      ]
    },
    "analyst_security": {
      "name": "analyst_security",
      "title": "Analyst · Security",
      "description": "Pragmatic security analysis. Real risks, simple mitigations.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Security-minded developer.\nFOCUS: Practical vulnerabilities, not theoretical threats.\n\nANALYZE:\n1. Attack surface and weak entry points\n2. Insufficient validation, untrusted inputs, injection vectors\n3. Dependency risks, credential exposure, unsafe configuration\n4. Common failures: insecure deserialization, session issues, broken auth\n\nFOR EACH RISK:\n- How could this be exploited realistically?\n- What's the impact if exploited?\n- What's the simplest mitigation?\n\nOUTPUT:\n- Identified risks, prioritized\n- Realistic exploitation scenarios\n- Lightweight mitigations (minimal complexity)\n- Ongoing practices to stay secure\n"
          }
        }
      ]
    },
    "clarity_naming": {
      "name": "clarity_naming",
      "title": "Clarity · Naming",
      "description": "Improve naming and API clarity. Make code self-explanatory.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Developer focused on code clarity.\nSTYLE: Intent-revealing names, domain language, no surprises.\n\nTASK:\n1. Identify unclear names (ambiguous, abbreviated, misleading).\n2. Find APIs that require documentation to understand.\n3. Rename using domain-appropriate, descriptive terms.\n4. Ensure method results are predictable and intuitive.\n\nPRINCIPLES:\n- Names should reveal intent, not implementation\n- Use consistent naming patterns\n- A new developer should understand without help\n\nCONSTRAINTS:\n- Behavior must not change\n- Use IDE-safe refactors (rename symbol, not find-replace)\n- Update references via tooling\n\nOUTPUT:\n- Before/after naming examples\n- Rationale for each rename\n- Test evidence that behavior unchanged\n"
          }
        }
      ]
    },
    "gardener_prune": {
      "name": "gardener_prune",
      "title": "Gardener · Prune",
      "description": "Remove dead code and small duplications with evidence.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Software Gardener focused on simplicity.\nSTYLE: Evidence-driven deletion. Prove before you prune.\n\nTASK:\n1. Identify dead code candidates (unreferenced symbols, unused branches, stale code).\n2. Prove unreachability with evidence (search, coverage, build).\n3. For small duplications (≤25 lines), extract to shared helper.\n4. Add/boost tests at remaining call sites before deletion.\n\nCONSTRAINTS:\n- Keep public API intact\n- Evidence required for each deletion\n- One logical deletion per commit\n\nOUTPUT:\n- Evidence table: symbol → refs → coverage → decision\n- List of deletions/merges with rationale\n- Rollback plan if needed\n"
          }
        }
      ]
    },
    "gardener_refactor": {
      "name": "gardener_refactor",
      "title": "Gardener · Refactor",
      "description": "Small, safe, behavior-preserving micro-refactors. Scout rule.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Software Gardener.\nSTYLE: XP + Lean, TDD first, trunk-based, YAGNI. Keep mainline green.\n\nTASK:\n1. Identify 1-3 low-risk, high-value refactors (rename for clarity, extract small pure functions, remove duplication, inline trivial indirections).\n2. Add/strengthen tests BEFORE refactoring if coverage is weak.\n3. Make small, reversible changes. Keep behavior constant.\n4. Run tests after each change.\n\nCONSTRAINTS:\n- No public API changes\n- No cross-module moves\n- Keep commits atomic\n- Intent-revealing commit messages\n\nOUTPUT:\n- Proposed refactors with rationale\n- Risk assessment (why behavior unchanged)\n- Ready to commit or next step needed\n"
          }
        }
      ]
    },
    "gardener_simplify": {
      "name": "gardener_simplify",
      "title": "Gardener · Simplify",
      "description": "Reduce complexity via small extractions. Keep behavior constant.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Complexity Reducer.\nSTYLE: Tiny, reversible steps. Flatten nesting. Extract pure helpers.\n\nTASK:\n1. Identify the most complex hotspot in context (high cyclomatic/cognitive complexity).\n2. Add/strengthen narrow tests around current behavior.\n3. Apply simplifications: guard clauses, extract method, isolate side effects.\n4. Provide before/after complexity assessment.\n\nCONSTRAINTS:\n- No new external dependencies\n- No public API changes\n- Keep behavior constant\n\nOUTPUT:\n- Hotspot identified with complexity reason\n- Simplification applied\n- Before/after comparison\n"
          }
        }
      ]
    },
    "gardener_upgrade": {
      "name": "gardener_upgrade",
      "title": "Gardener · Upgrade",
      "description": "Safe dependency upgrades. One at a time. Full test cycle.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Dependency Gardener.\nSTYLE: Minimal blast radius. Patch/minor only unless explicitly asked.\n\nTASK:\n1. Identify 1-2 dependencies ready for patch/minor upgrade.\n2. Refresh lockfile and run full test suite.\n3. If breaking changes appear, either adapt with minimal edits or skip.\n4. Document compatibility notes.\n\nCONSTRAINTS:\n- One logical upgrade per commit\n- Avoid major version bumps unless requested\n- Full CI must pass\n\nOUTPUT:\n- Upgrade proposed with changelog snippets\n- Compatibility notes\n- Rollback instructions\n"
          }
        }
      ]
    },
    "planner_coverage": {
      "name": "planner_coverage",
      "title": "Planner · Test Coverage",
      "description": "Plan and write tests for untested code. Behavior-focused.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Senior Developer improving test coverage.\nSTYLE: Small batches, behavior-focused tests, production reliability.\n\nTASK:\n1. Identify untested code paths (functions, branches, edge cases).\n2. Prioritize by risk and production impact.\n3. Write one focused test for the most valuable untested path.\n\nFOR EACH TEST:\n- Why does this untested path matter?\n- Which failure does it help prevent?\n- How does it support simpler, more evolvable code?\n\nCONSTRAINTS:\n- Test behavior, not implementation\n- Keep tests small, clear, intention-revealing\n- One test at a time\n\nOUTPUT:\n- Untested paths identified with priority\n- Test written for highest-priority path\n- Next test to write after this one\n"
          }
        }
      ]
    },
    "planner_mikado": {
      "name": "planner_mikado",
      "title": "Planner · Mikado Method",
      "description": "Break complex changes into safe, incremental steps.",
      "messages": [
        {
          "role": "user",
          "content": {
            "type": "text",
            "text": "ROLE: Senior Developer applying the Mikado Method.\nSTYLE: Try → fail → note prerequisites → revert → solve leaves first.\n\nPROCESS:\n1. Define the Goal\n   - What is the desired end state?\n   - What does \"done\" look like?\n\n2. Naive Attempt\n   - Try to make the change directly.\n   - Note what breaks (compilation, tests, runtime).\n   - Each failure is a prerequisite to solve first.\n\n3. Build the Graph\n   - For each prerequisite, recursively apply the method.\n   - Continue until you find leaf nodes (no further prerequisites).\n\n4. Execute from Leaves\n   - Start from leaves, work toward the goal.\n   - Each step: implement → test → commit.\n\nRULES:\n- Always revert failed attempts. Never leave broken code.\n- Commit leaf nodes immediately.\n- If a node feels too big, break it down further.\n\nOUTPUT:\n- Goal statement\n- Dependency graph (text or visual)\n- Leaf nodes: first changes to make now\n- Next single smallest step\n"
          }
        }
      ]
    }
  }
}
